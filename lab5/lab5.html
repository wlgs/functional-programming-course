<!DOCTYPE html>
<!-- saved from url=(0090)https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>Programowanie funkcyjne - laboratorium 5.</title>
  <meta name="generator" content="Haroopad 0.13.1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/img/favicon.ico" rel="icon" type="image/x-icon">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.github{padding:20px;font-family:"Helvetica Neue",Helvetica,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Segoe UI",AppleSDGothicNeo-Medium,'Malgun Gothic',Arial,freesans,sans-serif;font-size:15px;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.github a{color:#3269a0}.github a:hover{color:#4183c4}.github h2{border-bottom:1px solid #e6e6e6;line-height:1.6}.github h6{color:#777}.github hr{border:1px solid #e6e6e6}.github pre>code{font-size:.9em;font-family:Consolas,Inconsolata,Courier,monospace}.github blockquote>code,.github h1>code,.github h2>code,.github h3>code,.github h4>code,.github h5>code,.github h6>code,.github li>code,.github p>code,.github td>code{background-color:rgba(0,0,0,.07);font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;padding:.2em .5em;border:0}.github blockquote{border-left:4px solid #e6e6e6;padding:0 15px;font-style:italic}.github table{background-color:#fafafa}.github table tr td,.github table tr th{border:1px solid #e6e6e6}.github table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment,.hljs-javadoc{color:#800}.hljs-keyword,.hljs-list .hljs-keyword,.hljs-request,.hljs-status,.hljs-tag .hljs-title,.hljs-winutils,.http .hljs-title,.method,.nginx .hljs-title,.setting .hljs-value,.tex .hljs-command{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.apache .hljs-cbracket,.coffeescript .hljs-attribute,.hljs-attr_selector,.hljs-cdata,.hljs-date,.hljs-filter .hljs-argument,.hljs-regexp,.hljs-string,.hljs-tag .hljs-value{color:#080}.clojure .hljs-attribute,.css .hljs-function,.hljs-decorator,.hljs-hexcolor,.hljs-literal,.hljs-number,.hljs-pi,.hljs-prompt,.hljs-rules .hljs-value,.hljs-shebang,.hljs-sub .hljs-identifier,.hljs-symbol,.hljs-tag,.hljs-tag .hljs-keyword,.ini .hljs-title,.ruby .hljs-symbol .hljs-string{color:#066}.hljs-built_in,.hljs-class .hljs-id,.hljs-class .hljs-title,.hljs-dartdoc,.hljs-doctype,.hljs-javadoctag,.hljs-params,.hljs-phpdoc,.hljs-tag .hljs-attribute,.hljs-type,.hljs-typename,.hljs-variable,.hljs-yardoctag,.setting,.smalltalk .hljs-class{color:#606}.css .hljs-tag,.hljs-pseudo,.hljs-rules .hljs-property,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#f70;font-weight:700}.hljs-rules .hljs-keyword{color:#c5af75}.apache .hljs-sqbracket,.hljs-annotation,.nginx .hljs-built_in{color:#9b859d}.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor *{color:#444}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:gray;font-weight:700}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-yardoctag{font-weight:700}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:5px 0;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:5px;-webkit-border-radius:5px;-moz-border-radius:5px;-khtml-border-radius:5px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:1px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:.7em}.MathJax_MenuRadioCheck.RTL{right:.7em;left:auto}.MathJax_MenuLabel{padding:1px 2em 3px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #DDD;margin:4px 3px}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:#606872;color:#fff}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown github">
<h3 id="_laboratorium-5._"><a name="_laboratorium-5._" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#_laboratorium-5._"></a><em>Laboratorium 5.</em></h3><h5 id="0)-przygotowanie-środowiska"><a name="0)-przygotowanie-środowiska" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#0)-przygotowanie-%C5%9Brodowiska"></a>0) Przygotowanie środowiska</h5><p>W konsoli/terminalu wpisujemy kolejno</p><pre class="bash hljs"><code class="bash" data-origin="&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cd
$ mkdir haskell-lab5
$ cd haskell-lab5
&lt;/code&gt;&lt;/pre&gt;">$ <span class="hljs-built_in">cd</span>
$ mkdir haskell-lab5
$ <span class="hljs-built_in">cd</span> haskell-lab5
</code></pre><h5 id="1)-elementarne-operacje-i/0"><a name="1)-elementarne-operacje-i/0" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#1)-elementarne-operacje-i/0"></a>1) Elementarne operacje I/0</h5><ol>
<li><p>W konsoli GHCi wpisujemy kolejno</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i IO

ghci&amp;gt; :t getChar
ghci&amp;gt; getChar
a

ghci&amp;gt; let x = getChar
ghci&amp;gt; x
4
ghci&amp;gt; x
b
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">IO</span>

<span class="hljs-title">ghci</span>&gt; :t getChar
<span class="hljs-title">ghci</span>&gt; getChar
<span class="hljs-title">a</span>

<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> x = getChar
<span class="hljs-title">ghci</span>&gt; x
<span class="hljs-number">4</span>
<span class="hljs-title">ghci</span>&gt; x
<span class="hljs-title">b</span>
</code></pre>
</li><li>W konsoli GHCi wpisujemy kolejno<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t putChar
ghci&amp;gt; putChar a
ghci&amp;gt; :t putChar &#39;a&#39;
ghci&amp;gt; putChar &#39;a&#39;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t putChar
<span class="hljs-title">ghci</span>&gt; putChar a
<span class="hljs-title">ghci</span>&gt; :t putChar 'a'
<span class="hljs-title">ghci</span>&gt; putChar 'a'
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy kolejno</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t getLine
ghci&amp;gt; getLine
&quot;Hello&quot;
ghci&amp;gt; getLine
Hello

ghci&amp;gt; let line = getLine
ghci&amp;gt; line
Hello
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t getLine
<span class="hljs-title">ghci</span>&gt; getLine
<span class="hljs-string">"Hello"</span>
<span class="hljs-title">ghci</span>&gt; getLine
<span class="hljs-type">Hello</span>

<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> line = getLine
<span class="hljs-title">ghci</span>&gt; line
<span class="hljs-type">Hello</span>
</code></pre>
</li><li>W konsoli GHCi wpisujemy kolejno<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t putStr
ghci&amp;gt; putStr &quot;Hello&quot;
ghci&amp;gt; :t putStrLn
ghci&amp;gt; putStrLn &quot;Hello&quot;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t putStr
<span class="hljs-title">ghci</span>&gt; putStr <span class="hljs-string">"Hello"</span>
<span class="hljs-title">ghci</span>&gt; :t putStrLn
<span class="hljs-title">ghci</span>&gt; putStrLn <span class="hljs-string">"Hello"</span>
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy kolejno</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t print
ghci&amp;gt; print 1
ghci&amp;gt; print a
ghci&amp;gt; print (1,2)
ghci&amp;gt; print [1..5]

ghci&amp;gt; newtype IntBox = MkIntBox Int
ghci&amp;gt; let ib1 = MkIntBox 1
ghci&amp;gt; print ib1

ghci&amp;gt; newtype IntBox = MkIntBox Int deriving Show
ghci&amp;gt; let ib1 = MkIntBox 1
ghci&amp;gt; print ib1
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t print
<span class="hljs-title">ghci</span>&gt; print <span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; print a
<span class="hljs-title">ghci</span>&gt; print (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
<span class="hljs-title">ghci</span>&gt; print [<span class="hljs-number">1.</span>.<span class="hljs-number">5</span>]

<span class="hljs-title">ghci</span>&gt; <span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">IntBox</span> = <span class="hljs-type">MkIntBox</span> <span class="hljs-type">Int</span></span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> ib1 = <span class="hljs-type">MkIntBox</span> <span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; print ib1

<span class="hljs-title">ghci</span>&gt; <span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">IntBox</span> = <span class="hljs-type">MkIntBox</span> <span class="hljs-type">Int</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> ib1 = <span class="hljs-type">MkIntBox</span> <span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; print ib1
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy kolejno</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t return &#39;a&#39;
ghci&amp;gt; return &#39;a&#39;
ghci&amp;gt; :t return 1
ghci&amp;gt; return 1
ghci&amp;gt; :t return &quot;Hello&quot;
ghci&amp;gt; return &quot;Hello&quot;

ghci&amp;gt; let hello = return &quot;Hello&quot;
ghci&amp;gt; hello
ghci&amp;gt; show &quot;Hello&quot;
ghci&amp;gt; show hello
ghci&amp;gt; :t &quot;Hello&quot;
ghci&amp;gt; :t hello
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t return 'a'
<span class="hljs-title">ghci</span>&gt; return 'a'
<span class="hljs-title">ghci</span>&gt; :t return <span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; return <span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; :t return <span class="hljs-string">"Hello"</span>
<span class="hljs-title">ghci</span>&gt; return <span class="hljs-string">"Hello"</span>

<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> hello = return <span class="hljs-string">"Hello"</span>
<span class="hljs-title">ghci</span>&gt; hello
<span class="hljs-title">ghci</span>&gt; show <span class="hljs-string">"Hello"</span>
<span class="hljs-title">ghci</span>&gt; show hello
<span class="hljs-title">ghci</span>&gt; :t <span class="hljs-string">"Hello"</span>
<span class="hljs-title">ghci</span>&gt; :t hello
</code></pre>
</li></ol><h5 id="2)-łączenie-(sekwencje)-&#39;akcji&#39;-i/o----operatory-```&gt;&gt;```-(_then_)-i-```&gt;&gt;=```-(_bind_),-notacja-_do_"><a name="2)-łączenie-(sekwencje)-&#39;akcji&#39;-i/o----operatory-```&gt;&gt;```-(_then_)-i-```&gt;&gt;=```-(_bind_),-notacja-_do_" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#2)-%C5%82%C4%85czenie-(sekwencje)-&#39;akcji&#39;-i/o----operatory-%60%60%60%3E%3E%60%60%60-(_then_)-i-%60%60%60%3E%3E=%60%60%60-(_bind_),-notacja-_do_"></a>2) Łączenie (sekwencje) ‘akcji’ I/O — operatory <code>&gt;&gt;</code> (<em>then</em>) i <code>&gt;&gt;=</code> (<em>bind</em>), notacja <em>do</em></h5><ol>
<li>W konsoli GHCi wpisujemy kolejno<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t (&amp;gt;&amp;gt;)
ghci&amp;gt; putChar &#39;a&#39; &amp;gt;&amp;gt; putChar &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t (&gt;&gt;)
<span class="hljs-title">ghci</span>&gt; putChar 'a' &gt;&gt; putChar '\n'
</code></pre>
</li><li>W pliku <code>ex2.hs</code> wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;actSeq = putChar &#39;A&#39; &amp;gt;&amp;gt; putChar &#39;G&#39; &amp;gt;&amp;gt; putChar &#39;H&#39; &amp;gt;&amp;gt;  putChar &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">actSeq</span> = putChar '<span class="hljs-type">A'</span> &gt;&gt; putChar '<span class="hljs-type">G'</span> &gt;&gt; putChar '<span class="hljs-type">H'</span> &gt;&gt;  putChar '\n'
</code></pre>
(zapisujemy zmiany, wczytujemy plik do GHCi), w GHCi wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t actSeq
ghci&amp;gt; actSeq
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t actSeq
<span class="hljs-title">ghci</span>&gt; actSeq
</code></pre>
</li><li>W pliku <code>ex2.hs</code> dodajemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;doActSeq = do
  putChar &#39;A&#39;
  putChar &#39;G&#39;
  putChar &#39;H&#39;
  putChar &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">doActSeq</span> = <span class="hljs-keyword">do</span>
  putChar '<span class="hljs-type">A'</span>
  putChar '<span class="hljs-type">G'</span>
  putChar '<span class="hljs-type">H'</span>
  putChar '\n'
</code></pre>
(zapisujemy zmiany, wczytujemy plik do GHCi), w GHCi wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t putChar &#39;A&#39;
ghci&amp;gt; :t putChar &#39;\n&#39;
ghci&amp;gt; :t doActSeq
ghci&amp;gt; doActSeq
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t putChar '<span class="hljs-type">A'</span>
<span class="hljs-title">ghci</span>&gt; :t putChar '\n'
<span class="hljs-title">ghci</span>&gt; :t doActSeq
<span class="hljs-title">ghci</span>&gt; doActSeq
</code></pre>
</li><li>W konsoli GHCi wpisujemy kolejno<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t (&amp;gt;&amp;gt;=)
ghci&amp;gt; :t getLine
ghci&amp;gt; :t putStrLn
ghci&amp;gt; :t getLine &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t (&gt;&gt;=)
<span class="hljs-title">ghci</span>&gt; :t getLine
<span class="hljs-title">ghci</span>&gt; :t putStrLn
<span class="hljs-title">ghci</span>&gt; :t getLine &gt;&gt;= putStrLn
</code></pre>
</li><li><p>W pliku <code>ex2.hs</code> dodajemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;echo1 = getLine &amp;gt;&amp;gt;= putStrLn

doEcho1 = do
  line &amp;lt;- getLine
  putStrLn line
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">echo1</span> = getLine &gt;&gt;= putStrLn

<span class="hljs-title">doEcho1</span> = <span class="hljs-keyword">do</span>
  line &lt;- getLine
  putStrLn line
</code></pre>
<p>(zapisujemy zmiany, wczytujemy plik do GHCi), w GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t echo1
ghci&amp;gt; echo1
abc

ghci&amp;gt; :t doEcho1
ghci&amp;gt; doEcho1
abc
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t echo1
<span class="hljs-title">ghci</span>&gt; echo1
<span class="hljs-title">abc</span>

<span class="hljs-title">ghci</span>&gt; :t doEcho1
<span class="hljs-title">ghci</span>&gt; doEcho1
<span class="hljs-title">abc</span>
</code></pre>
</li><li><p>W pliku <code>ex2.hs</code> dadajemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;echo2 = getLine &amp;gt;&amp;gt;= \line -&amp;gt; putStrLn $ line ++ &quot;!&quot;

doEcho2 = do
  line &amp;lt;- getLine
  putStrLn $ line ++ &quot;!&quot;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">echo2</span> = getLine &gt;&gt;= \line -&gt; putStrLn $ line ++ <span class="hljs-string">"!"</span>

<span class="hljs-title">doEcho2</span> = <span class="hljs-keyword">do</span>
  line &lt;- getLine
  putStrLn $ line ++ <span class="hljs-string">"!"</span>
</code></pre>
<p>(zapisujemy zmiany, wczytujemy plik do GHCi), w GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t echo2
ghci&amp;gt; echo2
abc

ghci&amp;gt; :t doEcho2
ghci&amp;gt; doEcho2
abc
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t echo2
<span class="hljs-title">ghci</span>&gt; echo2
<span class="hljs-title">abc</span>

<span class="hljs-title">ghci</span>&gt; :t doEcho2
<span class="hljs-title">ghci</span>&gt; doEcho2
<span class="hljs-title">abc</span>
</code></pre>
</li><li><p>W pliku <code>ex2.hs</code> dadajemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;echo3 :: IO ()
echo3 =  getLine &amp;gt;&amp;gt;= \l1 -&amp;gt; getLine &amp;gt;&amp;gt;= \l2 -&amp;gt; putStrLn $ l1 ++ l2

dialog :: IO ()
dialog = putStr &quot;What is your happy number? &quot;
         &amp;gt;&amp;gt; getLine
         &amp;gt;&amp;gt;= \n -&amp;gt; let num = read n :: Int in
                   if num == 7
                   then putStrLn &quot;Ah, lucky 7!&quot;
                   else if odd num
                        then putStrLn &quot;Odd number! That&#39;s most people&#39;s choice...&quot;
                        else putStrLn &quot;Hm, even number? Unusual!&quot;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">echo3</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">echo3</span> =  getLine &gt;&gt;= \l1 -&gt; getLine &gt;&gt;= \l2 -&gt; putStrLn $ l1 ++ l2

<span class="hljs-title">dialog</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">dialog</span> = putStr <span class="hljs-string">"What is your happy number? "</span>
         &gt;&gt; getLine
         &gt;&gt;= \n -&gt; <span class="hljs-keyword">let</span> num = read n :: <span class="hljs-type">Int</span> <span class="hljs-keyword">in</span>
                   <span class="hljs-keyword">if</span> num == <span class="hljs-number">7</span>
                   <span class="hljs-keyword">then</span> putStrLn <span class="hljs-string">"Ah, lucky 7!"</span>
                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> odd num
                        <span class="hljs-keyword">then</span> putStrLn <span class="hljs-string">"Odd number! That's most people's choice..."</span>
                        <span class="hljs-keyword">else</span> putStrLn <span class="hljs-string">"Hm, even number? Unusual!"</span>
</code></pre>
<p>(zapisujemy zmiany, wczytujemy plik do GHCi) i sprawdzamy działanie <code>echo3</code> i <code>dialog</code></p>
</li><li><strong><em>Zadania</em></strong>:<ol>
<li>Napisać odpowiedniki <code>echo3</code> i <code>dialog</code> wykorzystujące notację <code>do</code></li><li>Napisać odpowiednik <code>twoQuestions</code> bez użycia notacji <code>do</code><pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;twoQuestions :: IO ()
twoQuestions = do
  putStr &quot;What is your name? &quot;
  name &amp;lt;- getLine
  putStr &quot;How old are you? &quot;
  age &amp;lt;- getLine
  print (name,age)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">twoQuestions</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">twoQuestions</span> = <span class="hljs-keyword">do</span>
  putStr <span class="hljs-string">"What is your name? "</span>
  name &lt;- getLine
  putStr <span class="hljs-string">"How old are you? "</span>
  age &lt;- getLine
  print (name,age)
</code></pre>
</li><li>(<em>opcjonalne</em>) Napisać ‘akcję’ <code>getLine'</code> odpowiadającą <code>getLine</code> z biblioteki <code>Prelude</code></li></ol>
</li></ol><h5 id="3)-&#39;akcje&#39;-i/o-jako-parametry-lub-wyniki-funkcji-oraz-elementy-struktur-danych-(_ćwiczenie-opcjonalne_)"><a name="3)-&#39;akcje&#39;-i/o-jako-parametry-lub-wyniki-funkcji-oraz-elementy-struktur-danych-(_ćwiczenie-opcjonalne_)" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#3)-&#39;akcje&#39;-i/o-jako-parametry-lub-wyniki-funkcji-oraz-elementy-struktur-danych-(_%C4%87wiczenie-opcjonalne_)"></a>3) ‘Akcje’ I/O jako parametry lub wyniki funkcji oraz elementy struktur danych (<em>ćwiczenie opcjonalne</em>)</h5><ol>
<li><p>W pliku <code>ex3.hs</code> wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;nTimes :: Int -&amp;gt; IO () -&amp;gt; IO ()
nTimes 0 action = return ()
nTimes n action = do
  action
  nTimes (n-1) action

ioActionFactory :: Int -&amp;gt; String -&amp;gt; IO ()
ioActionFactory n = case n of
  1 -&amp;gt; \name -&amp;gt; putStrLn (&quot;Good morning, &quot; ++ name)
  2 -&amp;gt; \name -&amp;gt; putStrLn (&quot;Good afternoon, &quot; ++ name)
  3 -&amp;gt; \name -&amp;gt; putStrLn (&quot;Good night, &quot; ++ name)
  _ -&amp;gt; \name -&amp;gt; putStrLn (&quot;Hello, &quot; ++ name)

actionList :: [IO ()]
actionList = [ioActionFactory 1 &quot;Ben&quot;,
              ioActionFactory 2 &quot;Joe&quot;,
              ioActionFactory 3 &quot;Ally&quot;]

sequence&#39;        :: [IO ()] -&amp;gt; IO ()
sequence&#39; []     =  return ()
sequence&#39; (a:as) =  do a
                       sequence&#39; as
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">nTimes</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">IO</span> () -&gt; <span class="hljs-type">IO</span> ()
<span class="hljs-title">nTimes</span> <span class="hljs-number">0</span> action = return ()
<span class="hljs-title">nTimes</span> n action = <span class="hljs-keyword">do</span>
  action
  nTimes (n-<span class="hljs-number">1</span>) action

<span class="hljs-title">ioActionFactory</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">IO</span> ()
<span class="hljs-title">ioActionFactory</span> n = <span class="hljs-keyword">case</span> n <span class="hljs-keyword">of</span>
  <span class="hljs-number">1</span> -&gt; \name -&gt; putStrLn (<span class="hljs-string">"Good morning, "</span> ++ name)
  <span class="hljs-number">2</span> -&gt; \name -&gt; putStrLn (<span class="hljs-string">"Good afternoon, "</span> ++ name)
  <span class="hljs-number">3</span> -&gt; \name -&gt; putStrLn (<span class="hljs-string">"Good night, "</span> ++ name)
  _ -&gt; \name -&gt; putStrLn (<span class="hljs-string">"Hello, "</span> ++ name)

<span class="hljs-title">actionList</span> :: [<span class="hljs-type">IO</span> ()]
<span class="hljs-title">actionList</span> = [ioActionFactory <span class="hljs-number">1</span> <span class="hljs-string">"Ben"</span>,
              ioActionFactory <span class="hljs-number">2</span> <span class="hljs-string">"Joe"</span>,
              ioActionFactory <span class="hljs-number">3</span> <span class="hljs-string">"Ally"</span>]

<span class="hljs-title">sequence'</span>        :: [<span class="hljs-type">IO</span> ()] -&gt; <span class="hljs-type">IO</span> ()
<span class="hljs-title">sequence'</span> []     =  return ()
<span class="hljs-title">sequence'</span> (a:<span class="hljs-keyword">as</span>) =  <span class="hljs-keyword">do</span> a
                       sequence' <span class="hljs-keyword">as</span>
</code></pre>
<p>(zapisujemy zmiany, wczytujemy plik do GHCi)</p>
</li><li><p>W GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; nTimes 3 (putStrLn &quot;Hathor&quot;)
ghci&amp;gt; sequence&#39; [putStrLn &quot;Hathor&quot;, putStrLn &quot;Hathor&quot;, putStrLn &quot;Hathor&quot;]

ghci&amp;gt; sequence&#39; actionList

ghci&amp;gt; :t sequence_
ghci&amp;gt; sequence_ actionList

ghci&amp;gt; :t sequence -- porównujemy wynik z poprzednim
ghci&amp;gt; sequence actionList

ghci&amp;gt; :t sequenceA  -- porównujemy wynik z poprzednimi
ghci&amp;gt; sequenceA actionList
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; nTimes <span class="hljs-number">3</span> (putStrLn <span class="hljs-string">"Hathor"</span>)
<span class="hljs-title">ghci</span>&gt; sequence' [putStrLn <span class="hljs-string">"Hathor"</span>, putStrLn <span class="hljs-string">"Hathor"</span>, putStrLn <span class="hljs-string">"Hathor"</span>]

<span class="hljs-title">ghci</span>&gt; sequence' actionList

<span class="hljs-title">ghci</span>&gt; :t sequence_
<span class="hljs-title">ghci</span>&gt; sequence_ actionList

<span class="hljs-title">ghci</span>&gt; :t sequence <span class="hljs-comment">-- porównujemy wynik z poprzednim</span>
<span class="hljs-title">ghci</span>&gt; sequence actionList

<span class="hljs-title">ghci</span>&gt; :t sequenceA  <span class="hljs-comment">-- porównujemy wynik z poprzednimi</span>
<span class="hljs-title">ghci</span>&gt; sequenceA actionList
</code></pre>
</li><li>W GHCi wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; foldr1 (&amp;gt;&amp;gt;) actionList
ghci&amp;gt; foldl1 (&amp;gt;&amp;gt;) actionList
ghci&amp;gt; foldr (&amp;gt;&amp;gt;) (return ()) actionList
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; foldr1 (&gt;&gt;) actionList
<span class="hljs-title">ghci</span>&gt; foldl1 (&gt;&gt;) actionList
<span class="hljs-title">ghci</span>&gt; foldr (&gt;&gt;) (return ()) actionList
</code></pre>
</li><li><strong><em>Zadania</em></strong>:<ol>
<li>Napisać odpowiednik <code>sequence'</code> wykorzystujący <code>foldr</code></li><li>Zmienić postać 1. agrumentu <code>foldr</code>: z <code>&gt;&gt;</code> na wyrażenie lambda</li><li>Napisać odpowiednik <code>sequence'</code> wykonujący ‘akcje’ od ostaniej do pierwszej; rozważyć co najmniej dwa warianty, np. <code>foldr</code> na odwróconej liście i wykorzystanie <code>foldl</code></li></ol>
</li></ol><h5 id="4)-elementarne-operacje-na-plikach-i-obsługa-wyjątków-i/o-(_ćwiczenie-opcjonalne_)"><a name="4)-elementarne-operacje-na-plikach-i-obsługa-wyjątków-i/o-(_ćwiczenie-opcjonalne_)" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#4)-elementarne-operacje-na-plikach-i-obs%C5%82uga-wyj%C4%85tk%C3%B3w-i/o-(_%C4%87wiczenie-opcjonalne_)"></a>4) Elementarne operacje na plikach i obsługa wyjątków I/O (<em>ćwiczenie opcjonalne</em>)</h5><ol>
<li><p>W pliku <code>ex4.hs</code> wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;import System.Environment
import System.IO

main = do
  (inFileName:outFileName:_) &amp;lt;- getArgs
  inHdlr &amp;lt;- openFile inFileName ReadMode
  outHdlr &amp;lt;- openFile outFileName WriteMode
  inpStr &amp;lt;- hGetContents inHdlr
  hPutStr outHdlr inpStr
  hClose inHdlr
  hClose outHdlr
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-import"><span class="hljs-keyword">import</span> System.Environment</span>
<span class="hljs-import"><span class="hljs-keyword">import</span> System.IO</span>

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  (inFileName:outFileName:_) &lt;- getArgs
  inHdlr &lt;- openFile inFileName <span class="hljs-type">ReadMode</span>
  outHdlr &lt;- openFile outFileName <span class="hljs-type">WriteMode</span>
  inpStr &lt;- hGetContents inHdlr
  hPutStr outHdlr inpStr
  hClose inHdlr
  hClose outHdlr
</code></pre>
<p>zapisujemy zmiany i sprawdzamy działanie (<code>runghc</code> + <code>cat</code>)</p>
</li><li>W terminalu/konsoli (nie GHCi) wpisujemy<pre><code class="console" data-origin="&lt;pre&gt;&lt;code class=&quot;console&quot;&gt;$ runghc ex4.hs tmp.hs
$ cat tmp.hs
&lt;/code&gt;&lt;/pre&gt;">$ runghc ex4.hs ex4.hs tmp.hs
$ cat tmp.hs
</code></pre>
</li><li><p>Modyfikujemy plik <code>ex4.hs</code> (zastępujemy poprzednią zawartość)</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;import System.Environment

main = do
  (inFileName:outFileName:_) &amp;lt;- getArgs
  inpStr &amp;lt;- readFile inFileName
  writeFile outFileName inpStr
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-import"><span class="hljs-keyword">import</span> System.Environment</span>

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  (inFileName:outFileName:_) &lt;- getArgs
  inpStr &lt;- readFile inFileName
  writeFile outFileName inpStr
</code></pre>
<p>zapisujemy zmiany i sprawdzamy działanie (jw. <code>runghc</code> + <code>cat</code>)</p>
</li><li><p>Modyfikujemy plik <code>ex4.hs</code> (zastępujemy poprzednią zawartość)</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;import System.Environment
import qualified Data.ByteString as BStr

main = do
  (inFileName:outFileName:_) &amp;lt;- getArgs
  inpBStr &amp;lt;- BStr.readFile inFileName
  BStr.writeFile outFileName inpBStr
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-import"><span class="hljs-keyword">import</span> System.Environment</span>
<span class="hljs-import"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.ByteString <span class="hljs-keyword">as</span> BStr</span>

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  (inFileName:outFileName:_) &lt;- getArgs
  inpBStr &lt;- <span class="hljs-type">BStr</span>.readFile inFileName
  <span class="hljs-type">BStr</span>.writeFile outFileName inpBStr
</code></pre>
<p>zapisujemy zmiany i sprawdzamy działanie (jw. <code>runghc</code> + <code>cat</code>)</p>
</li><li>W konsoli GHCi wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; import Control.Exception
ghci&amp;gt; :i Exception
ghci&amp;gt; :i SomeException
ghci&amp;gt; :t try
ghci&amp;gt; :t throw
ghci&amp;gt; :t catch
ghci&amp;gt; :t handle
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; <span class="hljs-import"><span class="hljs-keyword">import</span> Control.Exception</span>
<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Exception</span>
<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">SomeException</span>
<span class="hljs-title">ghci</span>&gt; :t try
<span class="hljs-title">ghci</span>&gt; :t throw
<span class="hljs-title">ghci</span>&gt; :t catch
<span class="hljs-title">ghci</span>&gt; :t handle
</code></pre>
</li><li>W konsoli GHCi wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; data MyException = MkMyException deriving Show
ghci&amp;gt; instance Exception MyException
ghci&amp;gt; throw MkMyException  `catch` \e -&amp;gt; putStrLn (&quot;Caught &quot; ++ show (e :: MyException))
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; <span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">MyException</span> = <span class="hljs-type">MkMyException</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">instance</span> <span class="hljs-type">Exception</span> <span class="hljs-type">MyException</span>
<span class="hljs-title">ghci</span>&gt; throw <span class="hljs-type">MkMyException</span>  `catch` \e -&gt; putStrLn (<span class="hljs-string">"Caught "</span> ++ show (e :: <span class="hljs-type">MyException</span>))
</code></pre>
</li><li><p>Modyfikujemy plik <code>ex4.hs</code> (zastępujemy poprzednią zawartość)</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;import System.Environment
import System.IO.Error
import Control.Exception

riskyAction :: IO ()
riskyAction = do (fileName:_) &amp;lt;- getArgs
                 contents &amp;lt;- readFile fileName
                 putStrLn contents

exHdlr :: IOError -&amp;gt; IO ()
exHdlr = \ex -&amp;gt; if isDoesNotExistError ex
                then putStrLn &quot;The file doesn&#39;t exist!&quot;
                else ioError ex

main :: IO ()
main = do
  result &amp;lt;- try riskyAction
  case result of
    Left ex -&amp;gt; exHdlr ex
    Right _ -&amp;gt; putStrLn &quot;Operation completed&quot;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-import"><span class="hljs-keyword">import</span> System.Environment</span>
<span class="hljs-import"><span class="hljs-keyword">import</span> System.IO.Error</span>
<span class="hljs-import"><span class="hljs-keyword">import</span> Control.Exception</span>

<span class="hljs-title">riskyAction</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">riskyAction</span> = <span class="hljs-keyword">do</span> (fileName:_) &lt;- getArgs
                 contents &lt;- readFile fileName
                 putStrLn contents

<span class="hljs-title">exHdlr</span> :: <span class="hljs-type">IOError</span> -&gt; <span class="hljs-type">IO</span> ()
<span class="hljs-title">exHdlr</span> = \ex -&gt; <span class="hljs-keyword">if</span> isDoesNotExistError ex
                <span class="hljs-keyword">then</span> putStrLn <span class="hljs-string">"The file doesn't exist!"</span>
                <span class="hljs-keyword">else</span> ioError ex

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  result &lt;- try riskyAction
  <span class="hljs-keyword">case</span> result <span class="hljs-keyword">of</span>
    <span class="hljs-type">Left</span> ex -&gt; exHdlr ex
    <span class="hljs-type">Right</span> _ -&gt; putStrLn <span class="hljs-string">"Operation completed"</span>
</code></pre>
<p>zapisujemy zmiany i sprawdzamy działanie, np. w konsoli/terminalu</p>
<pre><code class="console" data-origin="&lt;pre&gt;&lt;code class=&quot;console&quot;&gt;$ runghc ex4.hs ex4.hs
$ runghc ex4.hs non-existent.hs
&lt;/code&gt;&lt;/pre&gt;">$ runghc ex4.hs ex4.hs
$ runghc ex4.hs non-existent.hs
</code></pre>
</li><li>Modyfikujemy funkcję <code>main</code><pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;main = catch riskyAction exHdlr
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">main</span> = catch riskyAction exHdlr
</code></pre>
zapisujemy zmiany i sprawdzamy jej działanie (np. jw.)</li><li>Modyfikujemy funkcję <code>main</code><pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;main = handle exHdlr riskyAction
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">main</span> = handle exHdlr riskyAction
</code></pre>
zapisujemy zmiany i sprawdzamy jej działanie (np. jw.)</li><li>Modyfikujemy funkcję <code>main</code><pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;main = riskyAction `catch` exHdlr
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">main</span> = riskyAction `catch` exHdlr
</code></pre>
zapisujemy zmiany i sprawdzamy jej działanie (np. jw.)</li><li><strong><em>Zadania</em></strong>:<ol>
<li>Napisać program obliczający dla podanego pliku następujęce wskaźniki:<ul>
<li>liczbę linii,</li><li>liczbę wyrazów,</li><li>liczbę znaków,</li><li>liczbę różnych wyrazów</li><li>liczbę linii o długości większej niż 80 znaków</li></ul>
</li><li>Dodać do programu obsługę błędów (co najmniej: nieprawidłowa liczba argumentów wywołania, nieistniejący plik wejściowy)</li><li>Napisać program obliczający liczbę wystąpień zadanego słowa w pliku (dodać obsługę błędów)</li><li>Napisać program łączący zawartość plików podanych w argumentach wywołania (dodać obsługę błędów)</li><li>Zmodyfikować funkcję <code>exHdlr</code>: zamianst predykatu <code>isDoesNotExistError</code> (i wyrażenia warunkowego) użyć <code>IOErrorType</code> i mechanizmu dopasowania wzorców</li><li>Przeanalizować zawartość <code>Control.Exception</code> i <code>System.IO.Error</code></li></ol>
</li></ol><h5 id="5)-funktory-1:-operatory-```fmap```,-```()```-i-```(&lt;$)```"><a name="5)-funktory-1:-operatory-```fmap```,-```()```-i-```(&lt;$)```" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#5)-funktory-1:-operatory-%60%60%60fmap%60%60%60,-%60%60%60()%60%60%60-i-%60%60%60(%3C$)%60%60%60"></a>5) Funktory 1: operatory <code>fmap</code>, <code>(&lt;$&gt;)</code> i <code>(&lt;$)</code></h5><ol>
<li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i Functor
ghci&amp;gt; :t fmap (+1)

ghci&amp;gt; :i Either
ghci&amp;gt; fmap (+2) (Left 3)
ghci&amp;gt; fmap (+2) (Right 3)

ghci&amp;gt; :i []
ghci&amp;gt; fmap (*2) [1..5]
ghci&amp;gt; fmap (*2) []

ghci&amp;gt; :i Maybe
ghci&amp;gt; fmap (+1) (Just 3)
ghci&amp;gt; fmap (+1) Nothing

ghci&amp;gt; :i IO
ghci&amp;gt; import Data.Char
ghci&amp;gt; fmap toUpper getChar
a
ghci&amp;gt; fmap (map toUpper) getLine
abcde

ghci&amp;gt; :t fmap (+1) (*10)
ghci&amp;gt; fmap (+1) (*10) 1

ghci&amp;gt; fmap (+1) (0,0)
ghci&amp;gt; fmap (+1) (0,0,0)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Functor</span>
<span class="hljs-title">ghci</span>&gt; :t fmap (+<span class="hljs-number">1</span>)

<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Either</span>
<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">2</span>) (<span class="hljs-type">Left</span> <span class="hljs-number">3</span>)
<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">2</span>) (<span class="hljs-type">Right</span> <span class="hljs-number">3</span>)

<span class="hljs-title">ghci</span>&gt; :i []
<span class="hljs-title">ghci</span>&gt; fmap (*<span class="hljs-number">2</span>) [<span class="hljs-number">1.</span>.<span class="hljs-number">5</span>]
<span class="hljs-title">ghci</span>&gt; fmap (*<span class="hljs-number">2</span>) []

<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Maybe</span>
<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">1</span>) (<span class="hljs-type">Just</span> <span class="hljs-number">3</span>)
<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">1</span>) <span class="hljs-type">Nothing</span>

<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">IO</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-import"><span class="hljs-keyword">import</span> Data.Char</span>
<span class="hljs-title">ghci</span>&gt; fmap toUpper getChar
<span class="hljs-title">a</span>
<span class="hljs-title">ghci</span>&gt; fmap (map toUpper) getLine
<span class="hljs-title">abcde</span>

<span class="hljs-title">ghci</span>&gt; :t fmap (+<span class="hljs-number">1</span>) (*<span class="hljs-number">10</span>)
<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">1</span>) (*<span class="hljs-number">10</span>) <span class="hljs-number">1</span>

<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">1</span>) (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">1</span>) (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t ($)
ghci&amp;gt; :i ($)
ghci&amp;gt; (+2) $ 3

ghci&amp;gt; :t (&amp;lt;@@bodyamp;gt;)
ghci&amp;gt; :i (&amp;lt;@@bodyamp;gt;)

ghci&amp;gt; (+2) $ (Right 3)
ghci&amp;gt; (+2) &amp;lt;@@bodyamp;gt; (Right 3)

ghci&amp;gt; (*2) &amp;lt;@@bodyamp;gt; [1..5]

ghci&amp;gt; (+1) &amp;lt;@@bodyamp;gt; (Just 3)

ghci&amp;gt; toUpper &amp;lt;@@bodyamp;gt; getChar

ghci&amp;gt; (map toUpper) &amp;lt;@@bodyamp;gt; getLine
abcde

ghci&amp;gt; (+1) &amp;lt;@@bodyamp;gt; (*10) $ 1

ghci&amp;gt; (+1) &amp;lt;@@bodyamp;gt; (0,0)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t ($)
<span class="hljs-title">ghci</span>&gt; :i ($)
<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">2</span>) $ <span class="hljs-number">3</span>

<span class="hljs-title">ghci</span>&gt; :t (&lt;$&gt;)
<span class="hljs-title">ghci</span>&gt; :i (&lt;$&gt;)

<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">2</span>) $ (<span class="hljs-type">Right</span> <span class="hljs-number">3</span>)
<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">2</span>) &lt;$&gt; (<span class="hljs-type">Right</span> <span class="hljs-number">3</span>)

<span class="hljs-title">ghci</span>&gt; (*<span class="hljs-number">2</span>) &lt;$&gt; [<span class="hljs-number">1.</span>.<span class="hljs-number">5</span>]

<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">1</span>) &lt;$&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">3</span>)

<span class="hljs-title">ghci</span>&gt; toUpper &lt;$&gt; getChar

<span class="hljs-title">ghci</span>&gt; (map toUpper) &lt;$&gt; getLine
<span class="hljs-title">abcde</span>

<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">1</span>) &lt;$&gt; (*<span class="hljs-number">10</span>) $ <span class="hljs-number">1</span>

<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">1</span>) &lt;$&gt; (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i Functor
ghci&amp;gt; :t (&amp;lt;$)

ghci&amp;gt; 1 &amp;lt;$ Left 2
ghci&amp;gt; 1 &amp;lt;$ Right 2

ghci&amp;gt; &#39;a&#39; &amp;lt;$ [1..5]
ghci&amp;gt; &#39;a&#39; &amp;lt;$ []

ghci&amp;gt; &#39;a&#39; &amp;lt;$ Just 1
ghci&amp;gt; &#39;a&#39; &amp;lt;$ Nothing

ghci&amp;gt; 42 &amp;lt;$ getLine
abcd

ghci&amp;gt; 1 &amp;lt;$ (*10) $ 5
ghci&amp;gt; :t  1 &amp;lt;$ (*10)

ghci&amp;gt; 1 &amp;lt;$ (0,0)
ghci&amp;gt; 1 &amp;lt;$ (0,0,0)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Functor</span>
<span class="hljs-title">ghci</span>&gt; :t (&lt;$)

<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> &lt;$ <span class="hljs-type">Left</span> <span class="hljs-number">2</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> &lt;$ <span class="hljs-type">Right</span> <span class="hljs-number">2</span>

<span class="hljs-title">ghci</span>&gt; 'a' &lt;$ [<span class="hljs-number">1.</span>.<span class="hljs-number">5</span>]
<span class="hljs-title">ghci</span>&gt; 'a' &lt;$ []

<span class="hljs-title">ghci</span>&gt; 'a' &lt;$ <span class="hljs-type">Just</span> <span class="hljs-number">1</span>
<span class="hljs-title">ghci</span>&gt; 'a' &lt;$ <span class="hljs-type">Nothing</span>

<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">42</span> &lt;$ getLine
<span class="hljs-title">abcd</span>

<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> &lt;$ (*<span class="hljs-number">10</span>) $ <span class="hljs-number">5</span>
<span class="hljs-title">ghci</span>&gt; :t  <span class="hljs-number">1</span> &lt;$ (*<span class="hljs-number">10</span>)

<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> &lt;$ (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> &lt;$ (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
</code></pre>
<p>W jakich sytuacjach może być przydatny operator <code>(&lt;$)</code>?</p>
</li></ol><h5 id="6)-funktory-2:-dołączanie-typów-użytkownika-do-klasy-```functor```"><a name="6)-funktory-2:-dołączanie-typów-użytkownika-do-klasy-```functor```" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#6)-funktory-2:-do%C5%82%C4%85czanie-typ%C3%B3w-u%C5%BCytkownika-do-klasy-%60%60%60functor%60%60%60"></a>6) Funktory 2: dołączanie typów użytkownika do klasy <code>Functor</code></h5><ol>
<li><p>W pliku <code>ex6.hs</code> wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;newtype Box a = MkBox a deriving Show

instance Functor Box where
  fmap f (MkBox x) = MkBox (f x)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Box</span> a = <span class="hljs-type">MkBox</span> a <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Box</span> <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">MkBox</span> x) = <span class="hljs-type">MkBox</span> (f x)
</code></pre>
<p>(zapisujemy zmiany, wczytujemy plik do GHCi), w GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i Box
ghci&amp;gt; :i MkBox

ghci&amp;gt; fmap (^2) (MkBox 3)
ghci&amp;gt; 1 &amp;lt;$ MkBox 3
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Box</span>
<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">MkBox</span>

<span class="hljs-title">ghci</span>&gt; fmap (^<span class="hljs-number">2</span>) (<span class="hljs-type">MkBox</span> <span class="hljs-number">3</span>)
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> &lt;$ <span class="hljs-type">MkBox</span> <span class="hljs-number">3</span>
</code></pre>
</li><li>Modyfikujemy definicję <code>Box a</code><pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;newtype Box a = MkBox a deriving (Show, Functor)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Box</span> a = <span class="hljs-type">MkBox</span> a <span class="hljs-keyword">deriving</span> <span class="hljs-container">(<span class="hljs-type">Show</span>, <span class="hljs-type">Functor</span>)</span></span>
</code></pre>
</li><li>Zapisujemy zmiany, wczytujemy plik do GHCi (<code>:r</code>) i analizujemy komunikat błędu</li><li>W pierwszej linii pliku <code>ex6.hs</code> dodajemy rozszerzenie<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;{-# LANGUAGE DeriveFunctor #-}
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-pragma">{-# LANGUAGE DeriveFunctor #-}</span>
</code></pre>
</li><li>Zapisujemy zmiany, wczytujemy plik do GHCi (<code>:r</code>) i analizujemy komunikat błędu</li><li>Usuwamy (lub ‘zakomentowujemy’) definicję<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;instance Functor Box where
  fmap f (MkBox x) = MkBox (f x)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Box</span> <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">MkBox</span> x) = <span class="hljs-type">MkBox</span> (f x)
</code></pre>
zapisujemy zmiany, wczytujemy plik do GHCi i sprawdzamy działanie <code>fmap</code>, np.<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; fmap (^2) (MkBox 3)
ghci&amp;gt; 1 &amp;lt;$ MkBox 3
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; fmap (^<span class="hljs-number">2</span>) (<span class="hljs-type">MkBox</span> <span class="hljs-number">3</span>)
<span class="hljs-title">ghci</span>&gt; <span class="hljs-number">1</span> &lt;$ <span class="hljs-type">MkBox</span> <span class="hljs-number">3</span>
</code></pre>
</li><li><p>W pliku <code>ex6.hs</code> dodajemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;data MyList a = EmptyList
              | Cons a (MyList a) deriving Show

instance Functor MyList where
  fmap _ EmptyList    = EmptyList
  fmap f (Cons x mxs) = Cons (f x) (fmap f mxs)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">MyList</span> a = <span class="hljs-type">EmptyList</span></span>
              | <span class="hljs-type">Cons</span> a (<span class="hljs-type">MyList</span> a) <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">MyList</span> <span class="hljs-keyword">where</span></span>
  fmap _ <span class="hljs-type">EmptyList</span>    = <span class="hljs-type">EmptyList</span>
  fmap f (<span class="hljs-type">Cons</span> x mxs) = <span class="hljs-type">Cons</span> (f x) (fmap f mxs)
</code></pre>
<p>zapisujemy zmiany, wczytujemy plik do GHCi i sprawdzamy działanie <code>fmap</code>, np.</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; fmap (*2) EmptyList
ghci&amp;gt; let lst1 = Cons 1 (Cons 2 (Cons 3 (Cons 4 EmptyList)))
ghci&amp;gt; fmap id lst1
ghci&amp;gt; fmap (const 1) lst1
ghci&amp;gt; fmap (*2) lst1
ghci&amp;gt; fmap odd lst1
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; fmap (*<span class="hljs-number">2</span>) <span class="hljs-type">EmptyList</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> lst1 = <span class="hljs-type">Cons</span> <span class="hljs-number">1</span> (<span class="hljs-type">Cons</span> <span class="hljs-number">2</span> (<span class="hljs-type">Cons</span> <span class="hljs-number">3</span> (<span class="hljs-type">Cons</span> <span class="hljs-number">4</span> <span class="hljs-type">EmptyList</span>)))
<span class="hljs-title">ghci</span>&gt; fmap id lst1
<span class="hljs-title">ghci</span>&gt; fmap (const <span class="hljs-number">1</span>) lst1
<span class="hljs-title">ghci</span>&gt; fmap (*<span class="hljs-number">2</span>) lst1
<span class="hljs-title">ghci</span>&gt; fmap odd lst1
</code></pre>
</li><li><strong><em>Zadania</em></strong>:<ol>
<li>Sprawdzić możliwość automatycznego wygenerowania instancji <code>Functor</code> dla typu <code>MyList</code> (klauzula <em>deriving</em>)</li><li>Napisać własną implementację funktora (<code>instance Functor</code>), a następnie sprawdzić możliwość jej automatycznego wygenerowania dla drzewa binarnego zdefiniowanego jako<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;data BinTree a = EmptyBT | NodeBT a (BinTree a) (BinTree a) deriving (Show)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">BinTree</span> a = <span class="hljs-type">EmptyBT</span> | <span class="hljs-type">NodeBT</span> a <span class="hljs-container">(<span class="hljs-type">BinTree</span> <span class="hljs-title">a</span>)</span> <span class="hljs-container">(<span class="hljs-type">BinTree</span> <span class="hljs-title">a</span>)</span> <span class="hljs-keyword">deriving</span> <span class="hljs-container">(<span class="hljs-type">Show</span>)</span></span>
</code></pre>
</li><li>(<em>opcjonalne</em>) Napisać implementacje funktora (<code>instance Functor</code>) dla następujących typów:<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;newtype Pair b a = Pair { getPair :: (a,b) } -- fmap should change the first element
data Tree2 a = EmptyT2 | Leaf a | Node (Tree2 a) a (Tree2 a) deriving Show
data GTree a = Leaf a | GNode [GTree a] deriving Show
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Pair</span> b a = <span class="hljs-type">Pair</span> <span class="hljs-container">{ <span class="hljs-title">getPair</span> :: (<span class="hljs-title">a</span>,<span class="hljs-title">b</span>) }</span> <span class="hljs-comment">-- fmap should change the first element</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree2</span> a = <span class="hljs-type">EmptyT2</span> | <span class="hljs-type">Leaf</span> a | <span class="hljs-type">Node</span> <span class="hljs-container">(<span class="hljs-type">Tree2</span> <span class="hljs-title">a</span>)</span> a <span class="hljs-container">(<span class="hljs-type">Tree2</span> <span class="hljs-title">a</span>)</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">GTree</span> a = <span class="hljs-type">Leaf</span> a | <span class="hljs-type">GNode</span> [<span class="hljs-type">GTree</span> a] <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
</code></pre>
</li><li>(<em>opcjonalne</em>) Napisać implementację funktora (<code>instance Functor</code>) dla funkcji <code>a -&gt; b</code></li></ol>
</li></ol><h5 id="6)-funktory-aplikatywne-1:-operatory-```pure```,-```()```,-```(*&gt;)```-i-```(&lt;*)```"><a name="6)-funktory-aplikatywne-1:-operatory-```pure```,-```()```,-```(*&gt;)```-i-```(&lt;*)```" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#6)-funktory-aplikatywne-1:-operatory-%60%60%60pure%60%60%60,-%60%60%60()%60%60%60,-%60%60%60(*%3E)%60%60%60-i-%60%60%60(%3C*)%60%60%60"></a>7) Funktory aplikatywne 1: operatory <code>pure</code>, <code>(&lt;*&gt;)</code>, <code>(*&gt;)</code> i <code>(&lt;*)</code></h5><ol>
<li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i Applicative

ghci&amp;gt; fmap (+1) (Just 1)
ghci&amp;gt; (+1) &amp;lt;@@bodyamp;gt; (Just 1)
ghci&amp;gt; (+) &amp;lt;@@bodyamp;gt; (Just 1) (Just 2) -- analizujemy opis błędu
ghci&amp;gt; :t (+) &amp;lt;@@bodyamp;gt; (Just 1) -- w czym tkwi problem?

ghci&amp;gt; (+) &amp;lt;@@bodyamp;gt; (Just 1) &amp;lt;*&amp;gt; (Just 2)
ghci&amp;gt; pure (+) &amp;lt;*&amp;gt; (Just 1) &amp;lt;*&amp;gt; (Just 2)
ghci&amp;gt; :t pure (+) &amp;lt;*&amp;gt; (Just 1)

ghci&amp;gt; (\x y z -&amp;gt; x + y + z) &amp;lt;@@bodyamp;gt; Just 1 &amp;lt;*&amp;gt; Just 2 &amp;lt;*&amp;gt; Just 3
ghci&amp;gt; pure (\x y z -&amp;gt; x + y + z) &amp;lt;*&amp;gt; Just 1 &amp;lt;*&amp;gt; Just 2 &amp;lt;*&amp;gt; Just 3
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Applicative</span>

<span class="hljs-title">ghci</span>&gt; fmap (+<span class="hljs-number">1</span>) (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>)
<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">1</span>) &lt;$&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>)
<span class="hljs-title">ghci</span>&gt; (+) &lt;$&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>) (<span class="hljs-type">Just</span> <span class="hljs-number">2</span>) <span class="hljs-comment">-- analizujemy opis błędu</span>
<span class="hljs-title">ghci</span>&gt; :t (+) &lt;$&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>) <span class="hljs-comment">-- w czym tkwi problem?</span>

<span class="hljs-title">ghci</span>&gt; (+) &lt;$&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>) &lt;*&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">2</span>)
<span class="hljs-title">ghci</span>&gt; pure (+) &lt;*&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>) &lt;*&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">2</span>)
<span class="hljs-title">ghci</span>&gt; :t pure (+) &lt;*&gt; (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>)

<span class="hljs-title">ghci</span>&gt; (\x y z -&gt; x + y + z) &lt;$&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">3</span>
<span class="hljs-title">ghci</span>&gt; pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">3</span>
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i Applicative
ghci&amp;gt; :t pure

ghci&amp;gt; pure 1 :: Either Int Int
ghci&amp;gt; pure 1 :: Either a Int
ghci&amp;gt; pure 1 :: Either a Double

ghci&amp;gt; pure 1 :: [Int]
ghci&amp;gt; pure 1 :: [Double]

ghci&amp;gt; pure 1 :: Maybe Int
ghci&amp;gt; pure 1 :: IO Int

ghci&amp;gt; pure 1 :: (-&amp;gt;) r Int

ghci&amp;gt; pure 1 :: ((,) a Int)
ghci&amp;gt; pure 1 :: Monoid a =&amp;gt; ((,) a Int)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Applicative</span>
<span class="hljs-title">ghci</span>&gt; :t pure

<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: <span class="hljs-type">Either</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span>
<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: <span class="hljs-type">Either</span> a <span class="hljs-type">Int</span>
<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: <span class="hljs-type">Either</span> a <span class="hljs-type">Double</span>

<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: [<span class="hljs-type">Int</span>]
<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: [<span class="hljs-type">Double</span>]

<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span>
<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: <span class="hljs-type">IO</span> <span class="hljs-type">Int</span>

<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: (-&gt;) r <span class="hljs-type">Int</span>

<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: ((,) a <span class="hljs-type">Int</span>)
<span class="hljs-title">ghci</span>&gt; pure <span class="hljs-number">1</span> :: <span class="hljs-type">Monoid</span> a =&gt; ((,) a <span class="hljs-type">Int</span>)
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :t (&amp;lt;*&amp;gt;)

ghci&amp;gt; :i Either
ghci&amp;gt; pure (+1) &amp;lt;*&amp;gt; Left 0
ghci&amp;gt; pure (+1) &amp;lt;*&amp;gt; Right 0
ghci&amp;gt; Left (+1) &amp;lt;*&amp;gt; Left 0
ghci&amp;gt; Left (+1) &amp;lt;*&amp;gt; Right 0
ghci&amp;gt; Right (+1) &amp;lt;*&amp;gt; Right 0
ghci&amp;gt; :t pure (+1) &amp;lt;*&amp;gt; Left 0
ghci&amp;gt; :t pure (+1) &amp;lt;*&amp;gt; Right 0
ghci&amp;gt; :t Left (+1) &amp;lt;*&amp;gt; Left 0
ghci&amp;gt; :t Left (+1) &amp;lt;*&amp;gt; Right 0
ghci&amp;gt; :t Right (+1) &amp;lt;*&amp;gt; Right 0

ghci&amp;gt; :i []
ghci&amp;gt; pure (*2) &amp;lt;*&amp;gt; [1..5]
ghci&amp;gt; :t pure (*2)
ghci&amp;gt; :t pure (*2) :: [Int-&amp;gt;Int]
ghci&amp;gt; [(+1), (*2)] &amp;lt;*&amp;gt; [1,2,3]
ghci&amp;gt; (*) &amp;lt;@@bodyamp;gt; [1,2,3] &amp;lt;*&amp;gt; [100,101,102]

ghci&amp;gt; import Control.Applicative
ghci&amp;gt; :i ZipList
ghci&amp;gt; pure (+) &amp;lt;*&amp;gt; ZipList [1,2,3] &amp;lt;*&amp;gt; ZipList [100,100,100]
ghci&amp;gt; (+) &amp;lt;@@bodyamp;gt; ZipList [1,2,3] &amp;lt;*&amp;gt; ZipList [100,100..]

ghci&amp;gt; let timesList = fmap (*) [1..5]
ghci&amp;gt; :t timesList
ghci&amp;gt; fmap (\f -&amp;gt; f 3) timesList
ghci&amp;gt; (\f -&amp;gt; f 3) &amp;lt;@@bodyamp;gt; timesList
ghci&amp;gt; ($ 3) &amp;lt;@@bodyamp;gt; timesList
ghci&amp;gt; (:) &amp;lt;*&amp;gt; (\x -&amp;gt; [x]) $ 2

ghci&amp;gt; (++) &amp;lt;@@bodyamp;gt; Just &quot;Abra&quot; &amp;lt;*&amp;gt; Just &quot;kadabra&quot;
ghci&amp;gt; (++) &amp;lt;@@bodyamp;gt; Just &quot;Abra&quot; &amp;lt;*&amp;gt; Nothing
ghci&amp;gt; (++) &amp;lt;@@bodyamp;gt; Nothing &amp;lt;*&amp;gt; Just &quot;Abra&quot;
ghci&amp;gt; pure (\x y z -&amp;gt; (x,y,z)) &amp;lt;*&amp;gt; Just 1 &amp;lt;*&amp;gt; Just 2 &amp;lt;*&amp;gt; Just 3
ghci&amp;gt; (\x y z -&amp;gt; (x,y,z)) &amp;lt;@@bodyamp;gt; Just 1 &amp;lt;*&amp;gt; Just 2 &amp;lt;*&amp;gt; Just 3

ghci&amp;gt; (++) &amp;lt;@@bodyamp;gt; getLine &amp;lt;*&amp;gt; getLine
abc
def
ghci&amp;gt; (++) &amp;lt;@@bodyamp;gt; (fmap reverse getLine) &amp;lt;*&amp;gt; getLine
abc
def
ghci&amp;gt; :t getLine
ghci&amp;gt; :t fmap reverse getLine
ghci&amp;gt; (+) &amp;lt;@@bodyamp;gt; (fmap read) getLine &amp;lt;*&amp;gt; (fmap read) getLine

ghci&amp;gt; (+) &amp;lt;@@bodyamp;gt; (+1) &amp;lt;*&amp;gt; (*100) $ 5
ghci&amp;gt; (+) &amp;lt;@@bodyamp;gt; (^2) &amp;lt;*&amp;gt; (^3) $ 3
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :t (&lt;*&gt;)

<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Either</span>
<span class="hljs-title">ghci</span>&gt; pure (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Left</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; pure (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Right</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Left</span> (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Left</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Left</span> (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Right</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Right</span> (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Right</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; :t pure (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Left</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; :t pure (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Right</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; :t <span class="hljs-type">Left</span> (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Left</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; :t <span class="hljs-type">Left</span> (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Right</span> <span class="hljs-number">0</span>
<span class="hljs-title">ghci</span>&gt; :t <span class="hljs-type">Right</span> (+<span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">Right</span> <span class="hljs-number">0</span>

<span class="hljs-title">ghci</span>&gt; :i []
<span class="hljs-title">ghci</span>&gt; pure (*<span class="hljs-number">2</span>) &lt;*&gt; [<span class="hljs-number">1.</span>.<span class="hljs-number">5</span>]
<span class="hljs-title">ghci</span>&gt; :t pure (*<span class="hljs-number">2</span>)
<span class="hljs-title">ghci</span>&gt; :t pure (*<span class="hljs-number">2</span>) :: [<span class="hljs-type">Int</span>-&gt;<span class="hljs-type">Int</span>]
<span class="hljs-title">ghci</span>&gt; [(+<span class="hljs-number">1</span>), (*<span class="hljs-number">2</span>)] &lt;*&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-title">ghci</span>&gt; (*) &lt;$&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &lt;*&gt; [<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,<span class="hljs-number">102</span>]

<span class="hljs-title">ghci</span>&gt; <span class="hljs-import"><span class="hljs-keyword">import</span> Control.Applicative</span>
<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">ZipList</span>
<span class="hljs-title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="hljs-type">ZipList</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &lt;*&gt; <span class="hljs-type">ZipList</span> [<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>]
<span class="hljs-title">ghci</span>&gt; (+) &lt;$&gt; <span class="hljs-type">ZipList</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &lt;*&gt; <span class="hljs-type">ZipList</span> [<span class="hljs-number">100</span>,<span class="hljs-number">100.</span>.]

<span class="hljs-title">ghci</span>&gt; <span class="hljs-keyword">let</span> timesList = fmap (*) [<span class="hljs-number">1.</span>.<span class="hljs-number">5</span>]
<span class="hljs-title">ghci</span>&gt; :t timesList
<span class="hljs-title">ghci</span>&gt; fmap (\f -&gt; f <span class="hljs-number">3</span>) timesList
<span class="hljs-title">ghci</span>&gt; (\f -&gt; f <span class="hljs-number">3</span>) &lt;$&gt; timesList
<span class="hljs-title">ghci</span>&gt; ($ <span class="hljs-number">3</span>) &lt;$&gt; timesList
<span class="hljs-title">ghci</span>&gt; (:) &lt;*&gt; (\x -&gt; [x]) $ <span class="hljs-number">2</span>

<span class="hljs-title">ghci</span>&gt; (++) &lt;$&gt; <span class="hljs-type">Just</span> <span class="hljs-string">"Abra"</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-string">"kadabra"</span>
<span class="hljs-title">ghci</span>&gt; (++) &lt;$&gt; <span class="hljs-type">Just</span> <span class="hljs-string">"Abra"</span> &lt;*&gt; <span class="hljs-type">Nothing</span>
<span class="hljs-title">ghci</span>&gt; (++) &lt;$&gt; <span class="hljs-type">Nothing</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-string">"Abra"</span>
<span class="hljs-title">ghci</span>&gt; pure (\x y z -&gt; (x,y,z)) &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">3</span>
<span class="hljs-title">ghci</span>&gt; (\x y z -&gt; (x,y,z)) &lt;$&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span> &lt;*&gt; <span class="hljs-type">Just</span> <span class="hljs-number">3</span>

<span class="hljs-title">ghci</span>&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine
<span class="hljs-title">abc</span>
<span class="hljs-title">def</span>
<span class="hljs-title">ghci</span>&gt; (++) &lt;$&gt; (fmap reverse getLine) &lt;*&gt; getLine
<span class="hljs-title">abc</span>
<span class="hljs-title">def</span>
<span class="hljs-title">ghci</span>&gt; :t getLine
<span class="hljs-title">ghci</span>&gt; :t fmap reverse getLine
<span class="hljs-title">ghci</span>&gt; (+) &lt;$&gt; (fmap read) getLine &lt;*&gt; (fmap read) getLine

<span class="hljs-title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="hljs-number">1</span>) &lt;*&gt; (*<span class="hljs-number">100</span>) $ <span class="hljs-number">5</span>
<span class="hljs-title">ghci</span>&gt; (+) &lt;$&gt; (^<span class="hljs-number">2</span>) &lt;*&gt; (^<span class="hljs-number">3</span>) $ <span class="hljs-number">3</span>
</code></pre>
</li><li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; Left 1 *&amp;gt; Left 2
ghci&amp;gt; Right 1 *&amp;gt; Right 2

ghci&amp;gt; [1..2] *&amp;gt; [11..15]

ghci&amp;gt; Just 1 *&amp;gt; Just 2
ghci&amp;gt; Nothing *&amp;gt; Just 2

ghci&amp;gt; getLine *&amp;gt; getLine
abc
def

ghci&amp;gt; (+1) *&amp;gt; (*100) $ 5
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Left</span> <span class="hljs-number">1</span> *&gt; <span class="hljs-type">Left</span> <span class="hljs-number">2</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Right</span> <span class="hljs-number">1</span> *&gt; <span class="hljs-type">Right</span> <span class="hljs-number">2</span>

<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">1.</span>.<span class="hljs-number">2</span>] *&gt; [<span class="hljs-number">11.</span>.<span class="hljs-number">15</span>]

<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> *&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Nothing</span> *&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span>

<span class="hljs-title">ghci</span>&gt; getLine *&gt; getLine
<span class="hljs-title">abc</span>
<span class="hljs-title">def</span>

<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">1</span>) *&gt; (*<span class="hljs-number">100</span>) $ <span class="hljs-number">5</span>
</code></pre>
<p>W jakich sytuacjach może być przydatny operator <code>(*&gt;)</code>?</p>
</li><li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; Left 1 &amp;lt;* Left 2
ghci&amp;gt; Right 1 &amp;lt;* Right 2

ghci&amp;gt; [1..2] &amp;lt;* [11..15]

ghci&amp;gt; Just 1 &amp;lt;* Just 2
ghci&amp;gt; Just 1 &amp;lt;* Just 2
ghci&amp;gt; Just 2 &amp;lt;* Nothing

ghci&amp;gt; getLine &amp;lt;* getLine
abc
def

ghci&amp;gt; (+1) &amp;lt;* (*100) $ 5
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Left</span> <span class="hljs-number">1</span> &lt;* <span class="hljs-type">Left</span> <span class="hljs-number">2</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Right</span> <span class="hljs-number">1</span> &lt;* <span class="hljs-type">Right</span> <span class="hljs-number">2</span>

<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">1.</span>.<span class="hljs-number">2</span>] &lt;* [<span class="hljs-number">11.</span>.<span class="hljs-number">15</span>]

<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> &lt;* <span class="hljs-type">Just</span> <span class="hljs-number">2</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Just</span> <span class="hljs-number">1</span> &lt;* <span class="hljs-type">Just</span> <span class="hljs-number">2</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Just</span> <span class="hljs-number">2</span> &lt;* <span class="hljs-type">Nothing</span>

<span class="hljs-title">ghci</span>&gt; getLine &lt;* getLine
<span class="hljs-title">abc</span>
<span class="hljs-title">def</span>

<span class="hljs-title">ghci</span>&gt; (+<span class="hljs-number">1</span>) &lt;* (*<span class="hljs-number">100</span>) $ <span class="hljs-number">5</span>
</code></pre>
<p>W jakich sytuacjach może być przydatny operator <code>(&lt;*)</code>?</p>
</li></ol><h5 id="7)-funktory-aplikatywne-2:-dołączanie-typów-użytkownika-do-klasy-```applicative```"><a name="7)-funktory-aplikatywne-2:-dołączanie-typów-użytkownika-do-klasy-```applicative```" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#7)-funktory-aplikatywne-2:-do%C5%82%C4%85czanie-typ%C3%B3w-u%C5%BCytkownika-do-klasy-%60%60%60applicative%60%60%60"></a>8) Funktory aplikatywne 2: dołączanie typów użytkownika do klasy <code>Applicative</code></h5><ol>
<li><p>W pliku <code>ex7.hs</code> wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;newtype Box a = MkBox a deriving Show

instance Applicative Box where
  pure = MkBox
  (MkBox f) &amp;lt;*&amp;gt; w = fmap f w
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">Box</span> a = <span class="hljs-type">MkBox</span> a <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">Box</span> <span class="hljs-keyword">where</span></span>
  pure = <span class="hljs-type">MkBox</span>
  (<span class="hljs-type">MkBox</span> f) &lt;*&gt; w = fmap f w
</code></pre>
</li><li>Zapisujemy zmiany, wczytujemy plik do GHCi (<code>:r</code>) i analizujemy komunikat błędu</li><li>W pliku <code>ex7.hs</code> dodajemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;instance Functor Box where
  fmap f (MkBox x) = MkBox (f x)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Box</span> <span class="hljs-keyword">where</span></span>
  fmap f (<span class="hljs-type">MkBox</span> x) = <span class="hljs-type">MkBox</span> (f x)
</code></pre>
(zapisujemy zmiany, wczytujemy plik do GHCi), w GHCi wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; pure (*2) &amp;lt;*&amp;gt; MkBox 3
ghci&amp;gt; (*2) &amp;lt;@@bodyamp;gt; MkBox 3
ghci&amp;gt; (+) &amp;lt;@@bodyamp;gt; MkBox 1 &amp;lt;*&amp;gt; MkBox 2
ghci&amp;gt; (++) &amp;lt;@@bodyamp;gt; MkBox &quot;abc&quot; &amp;lt;*&amp;gt; MkBox &quot;def&quot;
ghci&amp;gt; (\x y z -&amp;gt; (z,y,x)) &amp;lt;@@bodyamp;gt; MkBox (Just 1) &amp;lt;*&amp;gt; MkBox (Just 2) &amp;lt;*&amp;gt; MkBox (Just 3)
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; pure (*<span class="hljs-number">2</span>) &lt;*&gt; <span class="hljs-type">MkBox</span> <span class="hljs-number">3</span>
<span class="hljs-title">ghci</span>&gt; (*<span class="hljs-number">2</span>) &lt;$&gt; <span class="hljs-type">MkBox</span> <span class="hljs-number">3</span>
<span class="hljs-title">ghci</span>&gt; (+) &lt;$&gt; <span class="hljs-type">MkBox</span> <span class="hljs-number">1</span> &lt;*&gt; <span class="hljs-type">MkBox</span> <span class="hljs-number">2</span>
<span class="hljs-title">ghci</span>&gt; (++) &lt;$&gt; <span class="hljs-type">MkBox</span> <span class="hljs-string">"abc"</span> &lt;*&gt; <span class="hljs-type">MkBox</span> <span class="hljs-string">"def"</span>
<span class="hljs-title">ghci</span>&gt; (\x y z -&gt; (z,y,x)) &lt;$&gt; <span class="hljs-type">MkBox</span> (<span class="hljs-type">Just</span> <span class="hljs-number">1</span>) &lt;*&gt; <span class="hljs-type">MkBox</span> (<span class="hljs-type">Just</span> <span class="hljs-number">2</span>) &lt;*&gt; <span class="hljs-type">MkBox</span> (<span class="hljs-type">Just</span> <span class="hljs-number">3</span>)
</code></pre>
</li><li><strong><em>Zadania</em></strong>:<ol>
<li>Napisać implementacje funktora aplikatywnego (<code>instance Applicative</code>) dla typu<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;newtype MyTriple a = MyTriple (a,a,a) deriving Show
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">newtype</span> <span class="hljs-type">MyTriple</span> a = <span class="hljs-type">MyTriple</span> <span class="hljs-container">(<span class="hljs-title">a</span>,<span class="hljs-title">a</span>,<span class="hljs-title">a</span>)</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
</code></pre>
</li><li>(<em>opcjonalne</em>) Napisać implementację funktora aplikatywnego (<code>instance Applicative</code>) dla funkcji <code>a -&gt; b</code></li><li>(<em>opcjonalne</em>) Napisać implementacje funktora aplikatywnego (<code>instance Applicative</code>) dla typu<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;data Tree2 a = EmptyT2 | Leaf a | Node (Tree2 a) a (Tree2 a) deriving Show
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree2</span> a = <span class="hljs-type">EmptyT2</span> | <span class="hljs-type">Leaf</span> a | <span class="hljs-type">Node</span> <span class="hljs-container">(<span class="hljs-type">Tree2</span> <span class="hljs-title">a</span>)</span> a <span class="hljs-container">(<span class="hljs-type">Tree2</span> <span class="hljs-title">a</span>)</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
</code></pre>
Uwaga: rozważyć dwa warianty — jak w przypadku list: iloczyn kartezjański i ZipList</li><li>(<em>opcjonalne</em>) Przeanalizować działanie funkcji <code>liftA</code>, <code>liftA2</code> i <code>liftA3</code> z <code>Control.Applicative</code></li></ol>
</li></ol><h5 id="8)-```monoid```,-```foldable```,-```traversable```-(_ćwiczenie-opcjonalne_)"><a name="8)-```monoid```,-```foldable```,-```traversable```-(_ćwiczenie-opcjonalne_)" href="https://upel2.cel.agh.edu.pl/wiet/pluginfile.php/97513/mod_resource/content/2/fp-lab5.html#8)-%60%60%60monoid%60%60%60,-%60%60%60foldable%60%60%60,-%60%60%60traversable%60%60%60-(_%C4%87wiczenie-opcjonalne_)"></a>9) <code>Monoid</code>, <code>Foldable</code>, <code>Traversable</code> (<em>ćwiczenie opcjonalne</em>)</h5><ol>
<li><p>W konsoli GHCi wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i Monoid

ghci&amp;gt; mempty

ghci&amp;gt; mempty :: [a]
ghci&amp;gt; [1,2,3] `mappend` [4,5,6]

ghci&amp;gt; :i Ordering
ghci&amp;gt; mempty :: Ordering
ghci&amp;gt; EQ `mappend` EQ
ghci&amp;gt; LT `mappend` LT
ghci&amp;gt; LT `mappend` EQ
ghci&amp;gt; LT `mappend` GT
ghci&amp;gt; EQ `mappend` LT
ghci&amp;gt; EQ `mappend` GT
ghci&amp;gt; GT `mappend` LT
ghci&amp;gt; GT `mappend` EQ
ghci&amp;gt; GT `mappend` GT

ghci&amp;gt; mempty :: (Monoid a =&amp;gt; Maybe a)
ghci&amp;gt; Nothing `mappend` Nothing
ghci&amp;gt; Nothing `mappend` Just &quot;Haskell&quot;
ghci&amp;gt; Just &quot;Haskell&quot; `mappend` Nothing
ghci&amp;gt; Just &quot;Me&quot; `mappend` Just &quot; and Haskell&quot;

ghci&amp;gt; mempty :: IO String
ghci&amp;gt; getLine `mappend` getLine
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Monoid</span>

<span class="hljs-title">ghci</span>&gt; mempty

<span class="hljs-title">ghci</span>&gt; mempty :: [a]
<span class="hljs-title">ghci</span>&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] `mappend` [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]

<span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Ordering</span>
<span class="hljs-title">ghci</span>&gt; mempty :: <span class="hljs-type">Ordering</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">EQ</span> `mappend` <span class="hljs-type">EQ</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">LT</span> `mappend` <span class="hljs-type">LT</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">LT</span> `mappend` <span class="hljs-type">EQ</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">LT</span> `mappend` <span class="hljs-type">GT</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">EQ</span> `mappend` <span class="hljs-type">LT</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">EQ</span> `mappend` <span class="hljs-type">GT</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">GT</span> `mappend` <span class="hljs-type">LT</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">GT</span> `mappend` <span class="hljs-type">EQ</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">GT</span> `mappend` <span class="hljs-type">GT</span>

<span class="hljs-title">ghci</span>&gt; mempty :: (<span class="hljs-type">Monoid</span> a =&gt; <span class="hljs-type">Maybe</span> a)
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Nothing</span> `mappend` <span class="hljs-type">Nothing</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Nothing</span> `mappend` <span class="hljs-type">Just</span> <span class="hljs-string">"Haskell"</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Just</span> <span class="hljs-string">"Haskell"</span> `mappend` <span class="hljs-type">Nothing</span>
<span class="hljs-title">ghci</span>&gt; <span class="hljs-type">Just</span> <span class="hljs-string">"Me"</span> `mappend` <span class="hljs-type">Just</span> <span class="hljs-string">" and Haskell"</span>

<span class="hljs-title">ghci</span>&gt; mempty :: <span class="hljs-type">IO</span> <span class="hljs-type">String</span>
<span class="hljs-title">ghci</span>&gt; getLine `mappend` getLine
</code></pre>
</li><li>W konsoli GHCi wpisujemy<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;ghci&amp;gt; :i Foldable
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-title">ghci</span>&gt; :i <span class="hljs-type">Foldable</span>
</code></pre>
</li><li><p>W pliku <code>ex8.hs</code> wpisujemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;data Tree2 a = EmptyT2 | Leaf a | NodeT2 (Tree2 a) a (Tree2 a) deriving Show

instance Foldable Tree2 where
  foldMap f EmptyT2        = mempty
  foldMap f (Leaf x)       = f x
  foldMap f (NodeT2 l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree2</span> a = <span class="hljs-type">EmptyT2</span> | <span class="hljs-type">Leaf</span> a | <span class="hljs-type">NodeT2</span> <span class="hljs-container">(<span class="hljs-type">Tree2</span> <span class="hljs-title">a</span>)</span> a <span class="hljs-container">(<span class="hljs-type">Tree2</span> <span class="hljs-title">a</span>)</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Foldable</span> <span class="hljs-type">Tree2</span> <span class="hljs-keyword">where</span></span>
  foldMap f <span class="hljs-type">EmptyT2</span>        = mempty
  foldMap f (<span class="hljs-type">Leaf</span> x)       = f x
  foldMap f (<span class="hljs-type">NodeT2</span> l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
</code></pre>
<p>zapisujemy zmiany, wczytujemy plik do GHCi i sprawdzamy działanie <code>foldMap</code> dla kilku drzew</p>
</li><li><p>W pliku <code>ex8.hs</code> dodajemy</p>
<pre class="haskell hljs"><code class="haskell" data-origin="&lt;pre&gt;&lt;code class=&quot;haskell&quot;&gt;instance Functor Tree2 where
  fmap f EmptyT2        = EmptyT2
  fmap f (Leaf x)       = Leaf $ f x
  fmap f (NodeT2 l x r) = NodeT2 (fmap f l)
                                 (f x)
                                 (fmap f r)

instance Traversable Tree2 where
  traverse f EmptyT2        = pure EmptyT2
  traverse f (Leaf x)       = Leaf &amp;lt;@@bodyamp;gt; f x
  traverse f (NodeT2 l x r) = NodeT2 &amp;lt;@@bodyamp;gt; traverse f l
                                     &amp;lt;*&amp;gt; f x
                                     &amp;lt;*&amp;gt; traverse f r
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> <span class="hljs-type">Tree2</span> <span class="hljs-keyword">where</span></span>
  fmap f <span class="hljs-type">EmptyT2</span>        = <span class="hljs-type">EmptyT2</span>
  fmap f (<span class="hljs-type">Leaf</span> x)       = <span class="hljs-type">Leaf</span> $ f x
  fmap f (<span class="hljs-type">NodeT2</span> l x r) = <span class="hljs-type">NodeT2</span> (fmap f l)
                                 (f x)
                                 (fmap f r)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Traversable</span> <span class="hljs-type">Tree2</span> <span class="hljs-keyword">where</span></span>
  traverse f <span class="hljs-type">EmptyT2</span>        = pure <span class="hljs-type">EmptyT2</span>
  traverse f (<span class="hljs-type">Leaf</span> x)       = <span class="hljs-type">Leaf</span> &lt;$&gt; f x
  traverse f (<span class="hljs-type">NodeT2</span> l x r) = <span class="hljs-type">NodeT2</span> &lt;$&gt; traverse f l
                                     &lt;*&gt; f x
                                     &lt;*&gt; traverse f r
</code></pre>
<p>zapisujemy zmiany, wczytujemy plik do GHCi i sprawdzamy działanie <code>traverse</code> dla kilku drzew</p>
</li></ol>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com/" target="_blank">haroopad</a></footer>


</body></html>